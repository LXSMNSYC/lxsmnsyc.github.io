<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/index.js | fast-complex</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Fast complex numbers in JavaScript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="fast-complex"><meta property="twitter:description" content="Fast complex numbers in JavaScript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/LXSMNSYC/fast-complex"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-abs">abs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-acos">acos</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-acosh">acosh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-add">add</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-arg">arg</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-asin">asin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-asinh">asinh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-atan">atan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-atanh">atanh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ceil">ceil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-conjugate">conjugate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cos">cos</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cosh">cosh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-div">div</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-equals">equals</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-euler">euler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-exp">exp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-floor">floor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isComplex">isComplex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ln">ln</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-log10">log10</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mul">mul</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-negate">negate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-polar">polar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pow">pow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-reciprocal">reciprocal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sign">sign</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sin">sin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sinh">sinh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sqrt">sqrt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sub">sub</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tan">tan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tanh">tanh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-zero">zero</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HALF_I">HALF_I</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-I">I</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NAN">NAN</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NI">NI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ONE">ONE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TWO">TWO</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ZERO">ZERO</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-complex">complex</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint-disable no-restricted-globals */
/* eslint-disable no-undef */
import assert from &apos;assert&apos;;
import {
  conjugate, I, NAN, zero,
  negate, ONE, NI, abs,
  acos, equals, acosh, asinh,
  asin, atan, atanh, tanh,
  tan, sinh, sin, cos,
  cosh, ceil, floor, exp,
  ln, log10, sqrt, euler,
  polar, sign, add, div,
  mul,
  pow,
  sub,
  reciprocal,
  arg,
} from &apos;../src&apos;;

describe(&apos;fast-complex&apos;, () =&gt; {
  /**
   *
   */
  describe(&apos;abs&apos;, () =&gt; {
    it(&apos;should return a number&apos;, () =&gt; {
      assert(typeof abs([1, 0]) === &apos;number&apos;);
    });
    it(&apos;should return the vector length of the complex&apos;, () =&gt; {
      assert(abs([1, 0]) === 1);
    });
    it(&apos;should return the same value if the given value is a number&apos;, () =&gt; {
      assert(abs(1) === 1);
    });
    it(&apos;should return NaN if the given value is not a complex.&apos;, () =&gt; {
      assert(isNaN(abs()));
    });
  });
  /**
   *
   */
  describe(&apos;acos&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(acos([1, 0]) instanceof Array);
    });
    it(&apos;should return the inverse cosine of the complex&apos;, () =&gt; {
      assert(equals(acos([1, 1]), [0.9045568943023813, -1.0612750619050355]));
    });
    it(&apos;should return the inverse cosine complex of the given number&apos;, () =&gt; {
      assert(equals(acos(1), [Math.acos(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === acos());
    });
  });
  /**
   *
   */
  describe(&apos;acosh&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(acosh([1, 0]) instanceof Array);
    });
    it(&apos;should return the hyperbolic inverse cosine of the complex&apos;, () =&gt; {
      assert(equals(acosh([1, 1]), [1.0612750619050355, 0.9045568943023813]));
    });
    it(&apos;should return the hyperbolic inverse cosine complex of the given number&apos;, () =&gt; {
      assert(equals(acosh(1), [Math.acosh(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === acosh());
    });
  });
  /**
   *
   */
  describe(&apos;add&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(add([1, 1], [1, 1]) instanceof Array);
    });
    it(&apos;should return the sum of two complex&apos;, () =&gt; {
      assert.deepEqual(add([1, 1], [1, 1]), [2, 2]);
    });
    it(&apos;should return the sum of a complex and a number&apos;, () =&gt; {
      assert.deepEqual(add([1, 1], 1), [2, 1]);
    });
    it(&apos;should return the sum of a number and a complex&apos;, () =&gt; {
      assert.deepEqual(add(1, [1, 1]), [2, 1]);
    });
    it(&apos;should return the sum of a number and a number&apos;, () =&gt; {
      assert.deepEqual(add(1, 1), [2, 0]);
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === add());
    });
  });
  /**
   *
   */
  describe(&apos;arg&apos;, () =&gt; {
    const eq = (a, b) =&gt; Math.abs(a - b) &lt;= 1e7 * Math.max(1, Math.abs(a), Math.abs(b));
    it(&apos;should return a number&apos;, () =&gt; {
      assert(typeof arg([1, 0]) === &apos;number&apos;);
    });
    it(&apos;should return the angle of the complex&apos;, () =&gt; {
      assert(eq(arg([1, 1]), 1.1071487177940904));
    });
    it(&apos;should return 0 if the given value is a number&apos;, () =&gt; {
      assert(eq(arg(1), 0));
    });
    it(&apos;should return NaN if the given value is not a complex.&apos;, () =&gt; {
      assert(isNaN(arg()));
    });
  });
  /**
   *
   */
  describe(&apos;asin&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(asin([1, 0]) instanceof Array);
    });
    it(&apos;should return the inverse sine of the complex&apos;, () =&gt; {
      assert(equals(asin([1, 1]), [0.6662394324925153, 1.0612750619050355]));
    });
    it(&apos;should return the inverse sine complex of the given number&apos;, () =&gt; {
      assert(equals(asin(1), [Math.asin(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === asin());
    });
  });
  /**
   *
   */
  describe(&apos;asinh&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(asinh([1, 0]) instanceof Array);
    });
    it(&apos;should return the hyperbolic inverse sine of the complex&apos;, () =&gt; {
      assert(equals(asinh([1, 1]), [1.0612750619050357, 0.6662394324925153]));
    });
    it(&apos;should return the hyperbolic inverse sine complex of the given number&apos;, () =&gt; {
      assert(equals(asinh(1), [Math.asinh(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === asinh());
    });
  });
  /**
   *
   */
  describe(&apos;atan&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(atan([1, 0]) instanceof Array);
    });
    it(&apos;should return the inverse tangent of the complex&apos;, () =&gt; {
      assert(equals(atan([1, 1]), [1.0172219678978514, 0.40235947810852507]));
    });
    it(&apos;should return the inverse tangent complex of the given number&apos;, () =&gt; {
      assert(equals(atan(1), [Math.atan(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === atan());
    });
  });
  /**
   *
   */
  describe(&apos;atanh&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(atanh([1, 0]) instanceof Array);
    });
    it(&apos;should return the hyperbolic inverse tangent of the complex&apos;, () =&gt; {
      assert(equals(atanh([1, 1]), [0.4023594781085251, 1.0172219678978514]));
    });
    it(&apos;should return the hyperbolic inverse tangent complex of the given number&apos;, () =&gt; {
      assert(equals(atanh(0.5), [Math.atanh(0.5), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === atanh());
    });
  });
  /**
   *
   */
  describe(&apos;ceil&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(ceil([1, 0]) instanceof Array);
    });
    it(&apos;should return the ceiling of the complex&apos;, () =&gt; {
      assert(equals(ceil([0.5, 0.5]), [1, 1]));
    });
    it(&apos;should return the ceiling complex of the given number&apos;, () =&gt; {
      assert(equals(ceil(0.5), [Math.ceil(0.5), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === ceil());
    });
  });
  /**
   *
   */
  describe(&apos;conjugate&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(conjugate(I) instanceof Array);
    });
    it(&apos;should negate the imaginary part of a complex&apos;, () =&gt; {
      assert.deepEqual(conjugate(I), NI);
    });
    it(&apos;should return an Array which real part is that of the value if the value is a number.&apos;, () =&gt; {
      assert.deepEqual(conjugate(1), ONE);
    });
    it(&apos;should return a NaN complex if the given value is not a complex.&apos;, () =&gt; {
      assert(conjugate() === NAN);
    });
  });
  /**
   *
   */
  describe(&apos;cos&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(cos([1, 0]) instanceof Array);
    });
    it(&apos;should return the cosine of the complex&apos;, () =&gt; {
      assert(equals(cos([1, 1]), [0.8337300251311491, -0.9888977057628651]));
    });
    it(&apos;should return the cosine complex of the given number&apos;, () =&gt; {
      assert(equals(cos(1), [Math.cos(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === cos());
    });
  });
  /**
   *
   */
  describe(&apos;cosh&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(cosh([1, 0]) instanceof Array);
    });
    it(&apos;should return the hyperbolic cosine of the complex&apos;, () =&gt; {
      assert(equals(cosh([1, 1]), [0.8337300251311491, 0.9888977057628651]));
    });
    it(&apos;should return the hyperbolic cosine complex of the given number&apos;, () =&gt; {
      assert(equals(cosh(1), [Math.cosh(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === cosh());
    });
  });
  /**
   *
   */
  describe(&apos;div&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(div([1, 1], [1, 1]) instanceof Array);
    });
    it(&apos;should return the quotient of two complex&apos;, () =&gt; {
      assert.deepEqual(div([1, 1], [1, 1]), [1, 0]);
    });
    it(&apos;should return the quotient of a complex and a number&apos;, () =&gt; {
      assert.deepEqual(div([1, 1], 1), [1, 1]);
    });
    it(&apos;should return the quotient of a number and a complex&apos;, () =&gt; {
      assert.deepEqual(div(1, [1, 1]), [1, 1]);
    });
    it(&apos;should return the quotient of a number and a number&apos;, () =&gt; {
      assert.deepEqual(div(1, 1), [1, 0]);
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === div());
    });
  });
  /**
   *
   */
  describe(&apos;exp&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(exp([1, 0]) instanceof Array);
    });
    it(&apos;should return the exp of the complex&apos;, () =&gt; {
      assert(equals(exp([1, 1]), [1.4686939399158851, 2.2873552871788423]));
    });
    it(&apos;should return the ceiling complex of the given number&apos;, () =&gt; {
      assert(equals(exp(1), [Math.exp(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === exp());
    });
  });
  /**
   *
   */
  describe(&apos;euler&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(euler(1) instanceof Array);
    });
    it(&apos;should return the euler of the complex&apos;, () =&gt; {
      assert(equals(euler(1), [0.5403023058681398, 0.8414709848078965]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === euler());
    });
  });
  /**
   *
   */
  describe(&apos;floor&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(floor([1, 0]) instanceof Array);
    });
    it(&apos;should return the floor of the complex&apos;, () =&gt; {
      assert(equals(floor([0.5, 0.5]), [0, 0]));
    });
    it(&apos;should return the ceiling complex of the given number&apos;, () =&gt; {
      assert(equals(floor(0.5), [Math.floor(0.5), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === floor());
    });
  });
  /**
   *
   */
  describe(&apos;ln&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(ln([1, 0]) instanceof Array);
    });
    it(&apos;should return the ln of the complex&apos;, () =&gt; {
      assert(equals(ln([1, 1]), [0.34657359027997264, 0.7853981633974483]));
    });
    it(&apos;should return the ceiling complex of the given number&apos;, () =&gt; {
      assert(equals(ln(1), [Math.log(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === ln());
    });
  });
  /**
   *
   */
  describe(&apos;log10&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(log10([1, 0]) instanceof Array);
    });
    it(&apos;should return the log10 of the complex&apos;, () =&gt; {
      assert(equals(log10([1, 1]), [0.15051499783199057, 0.3410940884604603]));
    });
    it(&apos;should return the ceiling complex of the given number&apos;, () =&gt; {
      assert(equals(log10(1), [Math.log10(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === log10());
    });
  });
  /**
   *
   */
  describe(&apos;mul&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(mul([1, 1], [1, 1]) instanceof Array);
    });
    it(&apos;should return the product of two complex&apos;, () =&gt; {
      assert.deepEqual(mul([1, 1], [1, 0]), [1, 1]);
    });
    it(&apos;should return the product of a complex and a number&apos;, () =&gt; {
      assert.deepEqual(mul([1, 1], 1), [1, 1]);
    });
    it(&apos;should return the product of a number and a complex&apos;, () =&gt; {
      assert.deepEqual(mul(1, [1, 1]), [1, 1]);
    });
    it(&apos;should return the product of a number and a number&apos;, () =&gt; {
      assert.deepEqual(mul(1, 1), [1, 0]);
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === mul());
    });
  });
  /**
   *
   */
  describe(&apos;negate&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(negate(ONE) instanceof Array);
    });
    it(&apos;should negate the real and imaginary part of a complex&apos;, () =&gt; {
      assert.deepEqual(negate([1, 1]), [-1, -1]);
    });
    it(&apos;should return an Array which real part is that of the value if the negated value is a number.&apos;, () =&gt; {
      assert.deepEqual(negate(1), [-1, 0]);
    });
    it(&apos;should return a NaN complex if the given value is not a complex.&apos;, () =&gt; {
      assert(negate() === NAN);
    });
  });
  /**
   *
   */
  describe(&apos;polar&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(polar(1, 1) instanceof Array);
    });
    it(&apos;should return the polar of the complex&apos;, () =&gt; {
      assert(equals(polar(1, 1), [0.5403023058681398, 0.8414709848078965]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === polar());
    });
  });
  /**
   *
   */
  describe(&apos;pow&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(pow([1, 1], [1, 1]) instanceof Array);
    });
    it(&apos;should return the power of two complex&apos;, () =&gt; {
      assert(equals(pow([1, 1], [1, 0]), [1, 1]));
    });
    it(&apos;should return the power of a complex and a number&apos;, () =&gt; {
      assert(equals(pow([1, 1], 1), [1, 1]));
    });
    it(&apos;should return the power of a number and a complex&apos;, () =&gt; {
      assert(equals(pow(1, [1, 1]), [1, 0]));
    });
    it(&apos;should return the power of a number and a number&apos;, () =&gt; {
      assert(equals(pow(1, 1), [1, 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === pow());
    });
  });
  /**
   *
   */
  describe(&apos;reciprocal&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(reciprocal([1, 0]) instanceof Array);
    });
    it(&apos;should return the reciprocal of the complex&apos;, () =&gt; {
      assert(equals(reciprocal([1, 1]), [0.5, -0.5]));
    });
    it(&apos;should return the reciprocal complex of the given number&apos;, () =&gt; {
      assert(equals(reciprocal(1), [1, 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === reciprocal());
    });
  });
  /**
   *
   */
  describe(&apos;sign&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(sign([1, 0]) instanceof Array);
    });
    it(&apos;should return the sine of the complex&apos;, () =&gt; {
      assert(equals(sign([1, 1]), [0.7071067811865475, 0.7071067811865475]));
    });
    it(&apos;should return the sine complex of the given number&apos;, () =&gt; {
      assert(equals(sign(1), [Math.sign(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === sign());
    });
  });
  /**
   *
   */
  describe(&apos;sin&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(sin([1, 0]) instanceof Array);
    });
    it(&apos;should return the sine of the complex&apos;, () =&gt; {
      assert(equals(sin([1, 1]), [1.2984575814159773, 0.6349639147847361]));
    });
    it(&apos;should return the sine complex of the given number&apos;, () =&gt; {
      assert(equals(sin(1), [Math.sin(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === sin());
    });
  });
  /**
   *
   */
  describe(&apos;sinh&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(sinh([1, 0]) instanceof Array);
    });
    it(&apos;should return the hyperbolic sine of the complex&apos;, () =&gt; {
      assert(equals(sinh([1, 1]), [0.6349639147847361, 1.2984575814159773]));
    });
    it(&apos;should return the hyperbolic sine complex of the given number&apos;, () =&gt; {
      assert(equals(sinh(1), [Math.sinh(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === sinh());
    });
  });
  /**
   *
   */
  describe(&apos;sqrt&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(sqrt([1, 0]) instanceof Array);
    });
    it(&apos;should return the log10 of the complex&apos;, () =&gt; {
      assert(equals(sqrt([1, 1]), [1.09868411346781, 0.45508986056222733]));
    });
    it(&apos;should return the square root complex of the given number&apos;, () =&gt; {
      assert(equals(sqrt(1), [Math.sqrt(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === sqrt());
    });
  });
  /**
   *
   */
  describe(&apos;sub&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(sub([1, 1], [1, 1]) instanceof Array);
    });
    it(&apos;should return the power of two complex&apos;, () =&gt; {
      assert(equals(sub([1, 1], [1, 1]), [0, 0]));
    });
    it(&apos;should return the power of a complex and a number&apos;, () =&gt; {
      assert(equals(sub([1, 1], 1), [0, 1]));
    });
    it(&apos;should return the power of a number and a complex&apos;, () =&gt; {
      assert(equals(sub(1, [1, 1]), [0, 1]));
    });
    it(&apos;should return the power of a number and a number&apos;, () =&gt; {
      assert(equals(sub(1, 1), [0, 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === sub());
    });
  });
  /**
   *
   */
  describe(&apos;tan&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(tan([1, 0]) instanceof Array);
    });
    it(&apos;should return the tangent of the complex&apos;, () =&gt; {
      assert(equals(tan([1, 1]), [0.27175258531951174, 1.0839233273386948]));
    });
    it(&apos;should return the tangent complex of the given number&apos;, () =&gt; {
      assert(equals(tan(1), [Math.tan(1), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === tan());
    });
  });
  /**
   *
   */
  describe(&apos;tanh&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(tanh([1, 0]) instanceof Array);
    });
    it(&apos;should return the hyperbolic tangent of the complex&apos;, () =&gt; {
      assert(equals(tanh([1, 1]), [1.0839233273386948, 0.27175258531951174]));
    });
    it(&apos;should return the hyperbolic tangent complex of the given number&apos;, () =&gt; {
      assert(equals(tanh(0.5), [Math.tanh(0.5), 0]));
    });
    it(&apos;should return NaN Complex if the given value is not a complex.&apos;, () =&gt; {
      assert(NAN === tanh());
    });
  });
  /**
   *
   */
  describe(&apos;zero&apos;, () =&gt; {
    it(&apos;should return an Array&apos;, () =&gt; {
      assert(zero() instanceof Array);
    });
    it(&apos;should return a complex with 0 real and imaginary part.&apos;, () =&gt; {
      const x = zero();
      assert(x[0] === 0 &amp;&amp; x[1] === 0);
    });
  });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
