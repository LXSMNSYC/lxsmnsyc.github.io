{"version":3,"sources":["components/Cursor.jsx","components/GLBackground.jsx","pages/Index.jsx","pages/Menu.jsx","pages/About.jsx","pages/Works.jsx","pages/Contacts.jsx","utils/stringLerp.js","components/NavItem.jsx","components/Nav.jsx","serviceWorker.js","index.js","App.jsx"],"names":["DETECTION_RADIUS","lerp","a","b","t","CURSOR","x","y","radius","growing","timer","targets","targetsL","targetsX","targetsY","targetsR","loadTarget","el","width","clientWidth","height","clientHeight","rect","getBoundingClientRect","top","hw","hh","left","addTarget","push","removeTarget","index","indexOf","splice","targetX","targetY","prevX","prevY","window","addEventListener","max","i","e","clientX","clientY","components_Cursor","cursorRef","useRef","useEffect","raf","cursor","current","update","dx","dy","transform","concat","found","tx","ty","tr","rad","MIN_RADIUS","style","webkitTransform","mozTransform","msTransform","oTransform","requestAnimationFrame","cancelAnimationFrame","react_default","createElement","id","ref","SCREEN_SCALE","getResolution","element","document","documentElement","w","Math","innerWidth","h","innerHeight","loadShader","context","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","components_GLBackground","props","canvasRef","_getResolution","useLayoutEffect","canvas","_getResolution2","currentW","currentH","gl","getContext","fragment","children","program","vsSource","fsSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","initShaderProgram","ploc","getAttribLocation","pbuff","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","uTime","getUniformLocation","uMouse","uRes","uORes","time","viewport","render","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","useProgram","enableVertexAttribArray","vertexAttribPointer","FLOAT","uniform1f","uniform2f","drawArrays","TRIANGLES","updateReso","_getResolution3","start","updateTime","ev","removeEventListener","Index","Fragment","Menu","About","Works","Contacts","charLerp","String","fromCharCode","charCodeAt","NavItem","_ref","target","end","navRef","item","reversed","innerHTML","str1","str2","mode","len1","length","len2","longer","result","indexValue","pos","floor","charAt","char1","char2","stringLerp","onMouseMove","react_router_dom","innerRef","className","to","Logo","title","split","map","components_Nav","Nav_Logo","Boolean","location","hostname","match","ReactDOM","hashType","react_router","exact","path","component","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"sPAMMA,SAAmB,IAOnBC,EAAO,SAACC,EAAGC,EAAGC,GAAP,OAAaF,EAAeE,EAAIA,GAAK,EAAI,EAAIA,IAA3BD,EAAID,IAE7BG,EAAS,CACbC,EAAG,EACHC,EAAG,EACHC,OAAQ,GAGNC,GAAU,EACVC,EAAQ,EAMRC,EAAU,EACRC,EAAW,GACXC,EAAW,GACXC,EAAW,GACXC,EAAW,GAGjB,SAASC,EAAWC,GAClB,IAAMC,EAAQD,EAAGE,YACXC,EAASH,EAAGI,aAEZC,EAAOL,EAAGM,wBAERC,EAAQF,EAARE,IAGFC,EAAa,GAARP,EACLQ,EAAc,GAATN,EAGLd,EANWgB,EAATK,KAMSF,EACXlB,EAAIiB,EAAME,EAEhBb,EAASF,GAAWL,EACpBQ,EAASH,GAAWJ,EACpBQ,EAASJ,GAAWX,GAAqBkB,EAAQE,EAAUM,EAAKD,GAChEd,GAAW,EApBbA,EAAU,EA+BH,IAAMiB,EAAY,SAACX,GACxBL,EAASiB,KAAKZ,GACdD,EAAWC,IAGAa,EAAe,SAACb,GAC3B,IAAMc,EAAQnB,EAASoB,QAAQf,GAE3Bc,GAAS,GACXnB,EAASqB,OAAOF,EAAO,IAIvBG,EAAU,EACVC,EAAU,EACVC,EAAQ,EACRC,EAAQ,EAEZC,OAAOC,iBAAiB,SA1BxB,WACE,IAAMC,EAAM7B,EACZA,EAAU,EACV,IAAK,IAAI8B,EAAI,EAAGA,EAAID,EAAKC,GAAK,EAC5BzB,EAAWJ,EAAS6B,MAwBxBH,OAAOC,iBAAiB,YAAa,SAACG,GACpCR,EAAUQ,EAAEC,QACZR,EAAUO,EAAEE,UAGC,IAAAC,EAAA,WACb,IAAMC,EAAYC,iBAAO,MA+EzB,OA7EAC,oBAAU,WACR,IAEIC,EAFEC,EAASJ,EAAUK,QA0EzB,OAtEe,SAATC,IACJ,IAAIC,EAAKnB,EAAUE,EACfkB,EAAKnB,EAAUE,EAEnBD,GAASiB,GA9FD,EAAI,IA+FZhB,GAASiB,GA/FD,EAAI,IAiGZjD,EAAOC,EAAI8B,EACX/B,EAAOE,EAAI8B,EAMX,IAJA,IAAIkB,EAAS,eAAAC,OAAkBpB,EAAQpC,EAA1B,QAAAwD,OAAiDnB,EAAQrC,EAAzD,UAGTyD,GAAQ,EACHhB,EAAI,EAAGA,EAAI9B,EAAS8B,GAAK,EAAG,CACnC,IAAMiB,EAAK7C,EAAS4B,GACdkB,EAAK7C,EAAS2B,GAEpBY,EAAKK,EAAKtB,EACVkB,EAAKK,EAAKtB,EAEV,IAAMuB,EAAK7C,EAAS0B,GAEpB,GAAIY,EAAKA,EAAKC,EAAKA,GAAMM,EAAKA,EAAI,CAChCnD,GAAU,EACVgD,GAAQ,EACR,OAGCA,IACHhD,GAAU,GAIZ,GAAIA,GACF,GAAIC,EA3HQ,EAAM,EA2HO,CACvB,IAAMN,EAAIM,GA5HA,EAAM,GA6HVmD,EAJQC,IAIU,IAAA7D,EAAK,EAAG,EAAGG,EAAIA,EAAIA,GAE3CC,EAAOG,OApIE,GAoIOqD,EAEhBN,GAAS,WAAAC,OAAeK,EAAf,KAAAL,OAAsBK,EAAtB,OAETnD,GAlIU,EAAI,SAoIX,GAAIA,EAAQ,EAAK,CACtB,IAAMN,EAAIM,GAtIE,EAAM,GAuIZmD,EAdUC,IAcQ,IAAA7D,EAAK,EAAG,EAAGG,EAAIA,EAAIA,GAE3CC,EAAOG,OA9II,GA8IKqD,EAEhBN,GAAS,SAAAC,OAAaK,EAAb,KAETnD,GA5IY,EAAI,QA8IhBL,EAAOG,OArJI,GAsJX+C,GAAS,SAAAC,OAvBOM,IAuBP,KAGXZ,EAAOa,MAAMC,gBAAkBT,EAC/BL,EAAOa,MAAME,aAAeV,EAC5BL,EAAOa,MAAMG,YAAcX,EAC3BL,EAAOa,MAAMI,WAAaZ,EAC1BL,EAAOa,MAAMR,UAAYA,EAEzBN,EAAMmB,sBAAsBhB,GAG9BA,GAEO,kBAAMiB,qBAAqBpB,MAGlCqB,EAAApE,EAAAqE,cAAA,OAAKC,GAAG,SAASC,IAAK3B,KCpKpB4B,SAAe,KAIrB,SAASC,IACP,IAAMC,EAAUC,SAASC,gBACzB,MAAO,CACLC,EAAGC,KAAKxC,IAAIoC,EAAQzD,YAAamB,OAAO2C,YAAc,GAAKP,EAC3DQ,EAAGF,KAAKxC,IAAIoC,EAAQvD,aAAciB,OAAO6C,aAAe,GAAKT,GAIjE,IAAMU,EAAa,SAACC,EAASC,EAAMC,GACjC,IAAMC,EAASH,EAAQI,aAAaH,GAYpC,OARAD,EAAQK,aAAaF,EAAQD,GAI7BF,EAAQM,cAAcH,GAIjBH,EAAQO,mBAAmBJ,EAAQH,EAAQQ,gBAMzCL,GAJLH,EAAQS,aAAaN,GACd,OA4BIO,EAAA,SAACC,GACd,IAAMC,EAAYlD,iBAAO,MADDmD,EAGQvB,IAArBzD,EAHagF,EAGhBnB,EAAa3D,EAHG8E,EAGNhB,EAiGlB,OA/FAiB,0BAAgB,WACd,IAAMC,EAASH,EAAU9C,QADLkD,EAGe1B,IAA1B2B,EAHWD,EAGdtB,EAAgBwB,EAHFF,EAGDnB,EAEbsB,EAAKJ,EAAOK,WAAW,SAE7B,IAAKD,EACH,OAAO,aAGT,IAAME,EAAWV,EAAMW,SAEjBC,EAxCgB,SAACvB,EAASwB,EAAUC,GAC5C,IAAMC,EAAe3B,EAAWC,EAASA,EAAQ2B,cAAeH,GAC1DI,EAAiB7B,EAAWC,EAASA,EAAQ6B,gBAAiBJ,GAI9DK,EAAgB9B,EAAQ+B,gBAO9B,OANA/B,EAAQgC,aAAaF,EAAeJ,GACpC1B,EAAQgC,aAAaF,EAAeF,GACpC5B,EAAQiC,YAAYH,GAIf9B,EAAQkC,oBAAoBJ,EAAe9B,EAAQmC,aAKjDL,EAHE,KAyBSM,CAAkBjB,EAxEvB,mFAwEmCE,GAExCgB,EAAOlB,EAAGmB,kBAAkBf,EAAS,cAErCgB,EAAQpB,EAAGqB,eACjBrB,EAAGsB,WAAWtB,EAAGuB,aAAcH,GAE/BpB,EAAGwB,WACDxB,EAAGuB,aACH,IAAIE,aAAa,EACd,GAAM,EACP,GAAM,GACL,EAAK,GACL,EAAK,EACN,GAAM,EACN,EAAK,IACPzB,EAAG0B,aAGL,IAAMC,EAAQ3B,EAAG4B,mBAAmBxB,EAAS,UACvCyB,EAAS7B,EAAG4B,mBAAmBxB,EAAS,WACxC0B,EAAO9B,EAAG4B,mBAAmBxB,EAAS,gBACtC2B,EAAQ/B,EAAG4B,mBAAmBxB,EAAS,WAEzC4B,EAAO,EAGXhC,EAAGiC,SAAS,EAAG,EAAGjC,EAAGJ,OAAOlF,MAAOsF,EAAGJ,OAAOhF,QAE7C,IAAMsH,EAAS,WACblC,EAAGmC,WAAW,EAAK,EAAK,EAAK,GAC7BnC,EAAGoC,MAAMpC,EAAGqC,iBAAmBrC,EAAGsC,kBAClCtC,EAAGuC,WAAWnC,GAEdJ,EAAGsB,WAAWtB,EAAGuB,aAAcH,GAC/BpB,EAAGwC,wBAAwBtB,GAC3BlB,EAAGyC,oBAAoBvB,EAAM,EAAGlB,EAAG0C,OAAO,EAAO,EAAG,GACpD1C,EAAG2C,UAAUhB,EAAOK,GACpBhC,EAAG4C,UAAUf,ED/FOhI,EAAOC,EAEPD,EAAOE,GC8F3BiG,EAAG4C,UAAUd,EAAMhC,EAAUC,GAC7BC,EAAG4C,UAAUb,EAAOjC,EAAW5B,EAAc6B,EAAW7B,GACxD8B,EAAG6C,WAAW7C,EAAG8C,UAAW,EAAG,IAG3BC,EAAa,WAAM,IAAAC,EACN7E,IAATI,EADeyE,EACfzE,EAAGG,EADYsE,EACZtE,EAEXkB,EAAOlF,MAAQ6D,EACfqB,EAAOhF,OAAS8D,EAEhBoB,EAAWvB,EACXwB,EAAWrB,EAEXsB,EAAGiC,SAAS,EAAG,EAAGjC,EAAGJ,OAAOlF,MAAOsF,EAAGJ,OAAOhF,SAG/CkB,OAAOC,iBAAiB,SAAUgH,GAElC,IAAIE,EAAQ,EAERxG,EAAM,GACS,SAAbyG,EAAcC,GACbF,IAAOA,EAAQE,GAEpBnB,GADQmB,EAAKF,GACE,IAEfxG,EAAMmB,sBAAsBsF,GAE9BA,CAAW,GAQX,OANe,SAATtG,IACJsF,IACAzF,EAAMmB,sBAAsBhB,GAE9BA,GAEO,WACLd,OAAOsH,oBAAoB,SAAUL,GACrClF,qBAAqBpB,MAKvBqB,EAAApE,EAAAqE,cAAA,UACEE,IAAKwB,EACLzB,GAAG,KACHtD,MAAOA,EACPE,OAAQA,KCpKCyI,EAAA,kBACbvF,EAAApE,EAAAqE,cAAAD,EAAApE,EAAA4J,SAAA,KACExF,EAAApE,EAAAqE,cAACwB,EAAD,0+bCHWgE,EAAA,kBACbzF,EAAApE,EAAAqE,cAAAD,EAAApE,EAAA4J,SAAA,KACExF,EAAApE,EAAAqE,cAACwB,EAAD,2pGCFWiE,EAAA,kBACb1F,EAAApE,EAAAqE,cAAAD,EAAApE,EAAA4J,SAAA,KACExF,EAAApE,EAAAqE,cAACwB,EAAD,4gHCFWkE,EAAA,kBACb3F,EAAApE,EAAAqE,cAAAD,EAAApE,EAAA4J,SAAA,KACExF,EAAApE,EAAAqE,cAACwB,EAAD,okHCFWmE,EAAA,kBACb5F,EAAApE,EAAAqE,cAAAD,EAAApE,EAAA4J,SAAA,KACExF,EAAApE,EAAAqE,cAACwB,EAAD,m8JCJEoE,EAAW,SAACjK,EAAGC,EAAGC,GAAP,OAAagK,OAAOC,aADxB,SAACnK,EAAGC,EAAGC,GAAP,OAAaF,EAAeE,EAAIA,GAAK,EAAI,EAAIA,IAA3BD,EAAID,GACeD,CAAKC,EAAEoK,WAAW,GAAInK,EAAEmK,WAAW,GAAIlK,KCY1EmK,EAAA,SAAAC,GAA4B,IAAzBC,EAAyBD,EAAzBC,OAAQhB,EAAiBe,EAAjBf,MAAOiB,EAAUF,EAAVE,IACzBC,EAAS5H,iBAAO,MAmEtB,OAjEAC,oBAAU,WACR,IAAM4H,EAAOD,EAAOxH,QAEpBvB,EAAUgJ,GAEV,IAEI3H,EAFAvC,EAAQ,EACRmK,GAAW,EAGTzH,EAAS,SAATA,IACAyH,EACEnK,EAAQ,IACVA,GArBS,EAAM,GAsBfuC,EAAMmB,sBAAsBhB,IAErB1C,EArBA,KAsBTA,GAzBW,EAAM,GA0BjBuC,EAAMmB,sBAAsBhB,IAE9BwH,EAAKE,UDhCI,SAACC,EAAMC,EAAM5K,EAAG6K,GAC7B,IAAI/K,EAAI6K,EACJ5K,EAAI6K,EAER,GAAI5K,GAAK,EACP,OAAO4K,EAET,GAAI5K,GAAK,EACP,OAAO2K,EAOT,IAAMG,EAAOhL,EAAEiL,OACTC,EAAOjL,EAAEgL,OAGTE,EAASrG,KAAKxC,IAAI0I,EAAME,GAG9B,GAAIF,EAAOE,EACT,IAAK,IAAI3I,EAAI2I,EAAOF,EAAMzI,EAAI,EAAGA,GAAK,EACpCvC,GAAK,SAEF,GAAIkL,EAAOF,EAChB,IAAK,IAAIzI,EAAIyI,EAAOE,EAAM3I,EAAI,EAAGA,GAAK,EACpCtC,GAAK,IAGT,IAAImL,EAAS,GACb,GAAa,IAATL,EAAY,CAQd,IANA,IAAMM,EAAa,EAAIF,EAGjBG,EAAMxG,KAAKxC,IAAI,EAAGwC,KAAKyG,MAAMJ,EAASjL,GAAK,GAGxCqC,EAAI,EAAGA,EAAI+I,EAAM,EAAG/I,GAAK,EAChC6I,GAAUnL,EAAEuL,OAAOjJ,GAIrB,IAAMkJ,EAAQzL,EAAEwL,OAAOF,EAAM,GACvBI,EAAQzL,EAAEuL,OAAOF,EAAM,GAI7BF,GAFqBnB,EAASwB,EAAOC,GADvBxL,EAAIoL,EAAMD,GAAcA,GAKtC,IAAK,IAAI9I,EAAI+I,EAAK/I,EAAI4I,EAAQ5I,GAAK,EACjC6I,GAAUpL,EAAEwL,OAAOjJ,GAGvB,GAAa,IAATwI,EACF,IAAK,IAAIxI,EAAI,EAAGA,EAAI4I,EAAQ5I,GAAK,EAAG,CAClC,IAAMkJ,EAAQzL,EAAEwL,OAAOjJ,GACjBmJ,EAAQzL,EAAEuL,OAAOjJ,GACvB6I,GAAUnB,EAASwB,EAAOC,EAAOxL,GAGrC,OAAOkL,EC/BcO,CAAWpC,EAAOiB,EAAKhK,EAzB7B,GACJ,IA2BHoL,EAAc,SAACpJ,GACnB,IAAMnC,EAAImC,EAAEE,QACNtC,EAAIoC,EAAEC,QAGNzB,EAAQ0J,EAAKzJ,YACbC,EAASwJ,EAAKvJ,aAEdC,EAAOsJ,EAAKrJ,wBAEVC,EAAQF,EAARE,IAUF6B,EAAK/C,GATMgB,EAATK,KAEW,GAART,GAQToC,EAAK/C,GAHIiB,EAJS,GAATJ,GASPiC,EAAKA,EAAKC,EAAKA,GAAMtD,KACnB6K,IACFA,GAAW,EACXzH,KAEQyH,IACVA,GAAW,EACXzH,MAMJ,OAFAd,OAAOC,iBAAiB,YAAauJ,GAE9B,WACLhK,EAAa8I,GACbvG,qBAAqBpB,GACrBX,OAAOsH,oBAAoB,YAAakC,MAK1CxH,EAAApE,EAAAqE,cAACwH,EAAA,EAAD,CACEC,SAAUrB,EACVsB,UAAU,WACVzH,GAAE,OAAAhB,OAASiH,GACXyB,GAAE,IAAA1I,OAAMiH,IAEPhB,IC9ED0C,SAAO,SAAA3B,GAAe,IAAZ4B,EAAY5B,EAAZ4B,MACR3H,EAAM1B,iBAAO,MAUnB,OATAC,oBAAU,WACR,IAAM4H,EAAOnG,EAAItB,QAIjB,OAFAvB,EAAUgJ,GAEH,WACL9I,EAAa8I,MAIftG,EAAApE,EAAAqE,cAACwH,EAAA,EAAD,CAAMC,SAAUvH,EAAKwH,UAAU,OAAOC,GAAG,KACtCE,EAAMC,MAAM,IAAIC,IAAI,SAAChM,EAAGmC,GAAJ,OAAW6B,EAAApE,EAAAqE,cAAA,QAAM0H,UAAS,OAAAzI,OAASf,IAAMnC,QAKrDiM,EAAA,kBACbjI,EAAApE,EAAAqE,cAAA,WACED,EAAApE,EAAAqE,cAACiI,EAAD,CAAMJ,MAAM,aACZ9H,EAAApE,EAAAqE,cAACgG,EAAD,CAASE,OAAO,WAAWhB,MAAM,WAAWiB,IAAI,aAChDpG,EAAApE,EAAAqE,cAACgG,EAAD,CAASE,OAAO,QAAQhB,MAAM,QAAQiB,IAAI,UAC1CpG,EAAApE,EAAAqE,cAACgG,EAAD,CAASE,OAAO,QAAQhB,MAAM,QAAQiB,IAAI,UAC1CpG,EAAApE,EAAAqE,cAACgG,EAAD,CAASE,OAAO,OAAOhB,MAAM,OAAOiB,IAAI,WCtBxB+B,QACW,cAA7BnK,OAAOoK,SAASC,UAEe,UAA7BrK,OAAOoK,SAASC,UAEhBrK,OAAOoK,SAASC,SAASC,MACvB,2DCZNC,IAASnE,OAAOpE,EAAApE,EAAAqE,cCOD,kBACbD,EAAApE,EAAAqE,cAACwH,EAAA,EAAD,CAAYe,SAAS,SACnBxI,EAAApE,EAAAqE,cAACgI,EAAD,MACAjI,EAAApE,EAAAqE,cAACwI,EAAA,EAAD,CAAOC,OAAK,EAACC,KAAK,IAAIC,UAAWrD,IACjCvF,EAAApE,EAAAqE,cAACwI,EAAA,EAAD,CAAOE,KAAK,SAASC,UAAWlD,IAChC1F,EAAApE,EAAAqE,cAACwI,EAAA,EAAD,CAAOE,KAAK,SAASC,UAAWjD,IAChC3F,EAAApE,EAAAqE,cAACwI,EAAA,EAAD,CAAOE,KAAK,QAAQC,UAAWnD,IAC/BzF,EAAApE,EAAAqE,cAACwI,EAAA,EAAD,CAAOE,KAAK,YAAYC,UAAWhD,IACnC5F,EAAApE,EAAAqE,cAAC1B,EAAD,QDfY,MAASgC,SAASsI,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.d4f5a80f.chunk.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\n\nimport '../css/Cursor.css';\n\nconst MIN_RADIUS = 16;\nconst MAX_RADIUS = 64;\nconst DETECTION_RADIUS = 32;\n\nconst STEPS = 1 / 16;\n\nconst GROWTH_TIME = 1.0 / 8.0;\nconst GROWTH_STEP = 1 / 64;\n\nconst lerp = (a, b, t) => a + (b - a) * (t * t * (3 - 2 * t));\n\nconst CURSOR = {\n  x: 0,\n  y: 0,\n  radius: 0,\n};\n\nlet growing = false;\nlet timer = 0.0;\n\nexport const getX = () => CURSOR.x;\n\nexport const getY = () => CURSOR.y;\n\nlet targets = 0;\nconst targetsL = [];\nconst targetsX = [];\nconst targetsY = [];\nconst targetsR = [];\n\ntargets = 0;\nfunction loadTarget(el) {\n  const width = el.clientWidth;\n  const height = el.clientHeight;\n\n  const rect = el.getBoundingClientRect();\n\n  const { top } = rect;\n  const { left } = rect;\n\n  const hw = width * 0.5;\n  const hh = height * 0.5;\n\n\n  const x = left + hw;\n  const y = top + hh;\n\n  targetsX[targets] = x;\n  targetsY[targets] = y;\n  targetsR[targets] = DETECTION_RADIUS + ((width > height) ? hh : hw);\n  targets += 1;\n}\n\nfunction loadTargets() {\n  const max = targets;\n  targets = 0;\n  for (let i = 0; i < max; i += 1) {\n    loadTarget(targetsL[i]);\n  }\n}\n\nexport const addTarget = (el) => {\n  targetsL.push(el);\n  loadTarget(el);\n};\n\nexport const removeTarget = (el) => {\n  const index = targetsL.indexOf(el);\n\n  if (index > -1) {\n    targetsL.splice(index, 1);\n  }\n};\n\nlet targetX = 0;\nlet targetY = 0;\nlet prevX = 0;\nlet prevY = 0;\n\nwindow.addEventListener('resize', loadTargets);\n\nwindow.addEventListener('mousemove', (e) => {\n  targetX = e.clientX;\n  targetY = e.clientY;\n});\n\nexport default () => {\n  const cursorRef = useRef(null);\n\n  useEffect(() => {\n    const cursor = cursorRef.current;\n\n    let raf;\n\n    const update = () => {\n      let dx = targetX - prevX;\n      let dy = targetY - prevY;\n\n      prevX += dx * STEPS;\n      prevY += dy * STEPS;\n\n      CURSOR.x = prevX;\n      CURSOR.y = prevY;\n\n      let transform = `translate3d(${prevX - DETECTION_RADIUS}px, ${prevY - DETECTION_RADIUS}px, 0)`;\n\n      // check for targets\n      let found = false;\n      for (let i = 0; i < targets; i += 1) {\n        const tx = targetsX[i];\n        const ty = targetsY[i];\n\n        dx = tx - prevX;\n        dy = ty - prevY;\n\n        const tr = targetsR[i];\n\n        if (dx * dx + dy * dy <= tr * tr) {\n          growing = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        growing = false;\n      }\n\n      const MIN_SCALE = MIN_RADIUS / MAX_RADIUS;\n      if (growing) {\n        if (timer < GROWTH_TIME) {\n          const t = timer / GROWTH_TIME;\n          const rad = MIN_SCALE + lerp(0, 1, t * t * t) * (1.0 - MIN_SCALE);\n\n          CURSOR.radius = rad * MAX_RADIUS;\n\n          transform += `scale3d(${rad},${rad},1)`;\n\n          timer += GROWTH_STEP;\n        }\n      } else if (timer > 0.0) {\n        const t = timer / GROWTH_TIME;\n        const rad = MIN_SCALE + lerp(0, 1, t * t * t) * (1.0 - MIN_SCALE);\n\n        CURSOR.radius = rad * MAX_RADIUS;\n\n        transform += `scale(${rad})`;\n\n        timer -= GROWTH_STEP;\n      } else {\n        CURSOR.radius = MIN_RADIUS;\n        transform += `scale(${MIN_SCALE})`;\n      }\n\n      cursor.style.webkitTransform = transform;\n      cursor.style.mozTransform = transform;\n      cursor.style.msTransform = transform;\n      cursor.style.oTransform = transform;\n      cursor.style.transform = transform;\n\n      raf = requestAnimationFrame(update);\n    };\n\n    update();\n\n    return () => cancelAnimationFrame(raf);\n  });\n  return (\n    <div id=\"cursor\" ref={cursorRef} />\n  );\n};\n","/* eslint-disable no-bitwise */\n/* eslint-disable react/prop-types */\nimport React, { useRef, useLayoutEffect } from 'react';\nimport { getX, getY } from './Cursor';\n\nimport '../css/GLBackground.css';\n\nconst SCREEN_SCALE = 1 / 4;\n\nconst VERTEX = 'attribute vec2 a_position; void main() { gl_Position = vec4(a_position, 0, 1); }';\n\nfunction getResolution() {\n  const element = document.documentElement;\n  return {\n    w: Math.max(element.clientWidth, window.innerWidth || 0) * SCREEN_SCALE,\n    h: Math.max(element.clientHeight, window.innerHeight || 0) * SCREEN_SCALE,\n  };\n}\n\nconst loadShader = (context, type, source) => {\n  const shader = context.createShader(type);\n\n  // Send the source to the shader object\n\n  context.shaderSource(shader, source);\n\n  // Compile the shader program\n\n  context.compileShader(shader);\n\n  // See if it compiled successfully\n\n  if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {\n    // alert('An error occurred compiling the shaders: ' + context.getShaderInfoLog(shader));\n    context.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n};\n\nconst initShaderProgram = (context, vsSource, fsSource) => {\n  const vertexShader = loadShader(context, context.VERTEX_SHADER, vsSource);\n  const fragmentShader = loadShader(context, context.FRAGMENT_SHADER, fsSource);\n\n  // Create the shader program\n\n  const shaderProgram = context.createProgram();\n  context.attachShader(shaderProgram, vertexShader);\n  context.attachShader(shaderProgram, fragmentShader);\n  context.linkProgram(shaderProgram);\n\n  // If creating the shader program failed, alert\n\n  if (!context.getProgramParameter(shaderProgram, context.LINK_STATUS)) {\n    // alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\n    return null;\n  }\n\n  return shaderProgram;\n};\n\n\nexport default (props) => {\n  const canvasRef = useRef(null);\n\n  const { w: width, h: height } = getResolution();\n\n  useLayoutEffect(() => {\n    const canvas = canvasRef.current;\n\n    let { w: currentW, h: currentH } = getResolution();\n\n    const gl = canvas.getContext('webgl');\n\n    if (!gl) {\n      return () => {};\n    }\n\n    const fragment = props.children;\n\n    const program = initShaderProgram(gl, VERTEX, fragment);\n\n    const ploc = gl.getAttribLocation(program, 'a_position');\n\n    const pbuff = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, pbuff);\n\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array([\n        -1.0, -1.0,\n        1.0, -1.0,\n        -1.0, 1.0,\n        -1.0, 1.0,\n        1.0, -1.0,\n        1.0, 1.0]),\n      gl.STATIC_DRAW,\n    );\n\n    const uTime = gl.getUniformLocation(program, 'u_time');\n    const uMouse = gl.getUniformLocation(program, 'u_mouse');\n    const uRes = gl.getUniformLocation(program, 'u_resolution');\n    const uORes = gl.getUniformLocation(program, 'u_oreso');\n\n    let time = 0.0;\n    let stamp = 0.0;\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    const render = () => {\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      gl.useProgram(program);\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, pbuff);\n      gl.enableVertexAttribArray(ploc);\n      gl.vertexAttribPointer(ploc, 2, gl.FLOAT, false, 0, 0);\n      gl.uniform1f(uTime, time);\n      gl.uniform2f(uMouse, getX(), getY());\n      gl.uniform2f(uRes, currentW, currentH);\n      gl.uniform2f(uORes, currentW / SCREEN_SCALE, currentH / SCREEN_SCALE);\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n    };\n\n    const updateReso = () => {\n      const { w, h } = getResolution();\n\n      canvas.width = w;\n      canvas.height = h;\n\n      currentW = w;\n      currentH = h;\n\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    };\n\n    window.addEventListener('resize', updateReso);\n\n    let start = 0;\n\n    let raf = 0;\n    const updateTime = (ev) => {\n      if (!start) start = ev;\n      stamp = ev - start;\n      time = stamp / 1000.0;\n\n      raf = requestAnimationFrame(updateTime);\n    };\n    updateTime(0);\n\n    const update = () => {\n      render();\n      raf = requestAnimationFrame(update);\n    };\n    update();\n\n    return () => {\n      window.removeEventListener('resize', updateReso);\n      cancelAnimationFrame(raf);\n    };\n  });\n\n  return (\n    <canvas\n      ref={canvasRef}\n      id=\"gl\"\n      width={width}\n      height={height}\n    />\n  );\n};\n","import React from 'react';\n\nimport GLBackground from '../components/GLBackground';\n\nexport default () => (\n  <>\n    <GLBackground>\n      {`\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n        #else\n        precision mediump float;\n        #endif\n        precision mediump int;\n        uniform vec2 u_resolution;\n        uniform vec2 u_oreso;\n        uniform vec2 u_mouse;\n        uniform float u_time;\n        const float PI = 3.14159265358979323;\n        const float CAMERA_FOV = 25.;\n        const float CAMERA_OFFSET = 16.;\n        const float RAY_T_MIN = 0.0001;\n        const float RAY_T_MAX = 1.0e30;\n        const vec3 EMPTY_VEC3 = vec3(1, 1, 1);\n        const int DEPTH = 1;\n        const int SPHERES = 3;\n        const float TIME_SCALE = 0.25;\n        const float SPHERE_RADIUS = 6.;\n        const float SPHERE_STEP = 0.25;\n        const float SPHERE_RADIUS_GROWTH = 3.;\n        const float SPHERE_SCALE_GROWTH = 1.0;\n        const float SPHERE_DISP_GROWTH = 1.0;\n        const float SPHERE_STEP_GROWTH = 0.25;\n        const vec2 SPHERE_BNS = vec2(8, 8);\n        const int LIGHTS = 1;\n        const vec3 BRIGHTNESS = vec3(1, 1, 1);\n        struct Material{\n        vec3 specular;\n        float shininess;\n        bool reflective;\n        float reflectN;\n        bool refractive;\n        float refractN;\n        };\n        const Material EMPTY_MATERIAL = Material(EMPTY_VEC3, 0., false, 0.0, false, 0.0);\n        struct Ray{\n        vec3 point;\n        vec3 direction;\n        float tMax;\n        };\n        struct Sphere{\n        vec3 center;\n        float radius;\n        vec2 noiseScale;\n        vec2 noiseDisp;\n        float noiseStep;\n        Material m;\n        };\n        struct Hit{\n        bool hit;\n        float tMax;\n        vec3 point, normal;\n        Material m;\n        vec3 color;\n        };\n        struct Eye{\n        vec3 point;\n        vec3 forward;\n        vec3 up;\n        vec3 right;\n        float h;\n        float w;\n        };\n        struct Light{\n        vec3 point, intensity;\n        float attn;\n        float ambient;\n        };\n        const Hit NO_HIT = Hit(false, RAY_T_MAX, EMPTY_VEC3, EMPTY_VEC3, EMPTY_MATERIAL, EMPTY_VEC3);\n        vec3 refraction(vec3 I, vec3 N, float ior){\n\n        float cosi = clamp(-1., 1., dot(I, N)); \n        float etai = 1., etat = ior; \n        vec3 n = N; \n        if (cosi < 0.) { \n          cosi = -cosi; \n        } else { \n          float tmp = etai;\n          etai = etat;\n          etat = tmp;\n          n= -N; \n        } \n        float eta = etai / etat; \n        float k = 1. - eta * eta * (1. - cosi * cosi); \n        if(k < 0.){\n          return EMPTY_VEC3;\n        }\n\n        return eta * I + (eta * cosi - sqrt(k)) * n; \n        }\n        // Simplex 3D Noise \n        // by Ian McEwan, Ashima Arts\n        //\n        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n        float snoise(vec3 v){ \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n        // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n        // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n        //  x0 = x0 - 0. + 0.0 * C \n        vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n        vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n        vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n        // Permutations\n        i = mod(i, 289.0 ); \n        vec4 p = permute( permute( permute( \n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n        // Gradients\n        // ( N*N points uniformly over a square, mapped onto an octahedron.)\n        float n_ = 1.0/7.0; // N=7\n        vec3  ns = n_ * D.wyz - D.xzx;\n        vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n        //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n        // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                      dot(p2,x2), dot(p3,x3) ) );\n        }\n        float getNoise(Sphere s, vec3 phit){\n        // check if it is in perlin noise\n        vec3 diff = normalize(phit - s.center);\n        float longi = diff.z;\n        float lati = diff.x;\n        longi = (longi + PI)*180./PI;\n        lati = (lati + PI)*180./PI;\n        longi /= 360.; \n        lati /= 360.;\n        return step(snoise(vec3(vec2(longi, lati)*s.noiseScale + s.noiseDisp + vec2(u_time, u_time), u_time*TIME_SCALE) ), s.noiseStep);\n        }\n        Hit intersect(Ray r, Sphere s, float et){\n        Ray local = Ray(r.point, r.direction, r.tMax);\n        local.point -= s.center;\n        // Calculate quadratic coefficients\n        float dl = length(local.direction);\n        float a = dl*dl;\n        float b = 2. * dot(local.direction, local.point);\n        float ol = length(local.point);\n        float sr = s.radius;\n        float c = ol*ol  - sr;\n        float discriminant = b*b - 4. * a * c;\n        if (discriminant < 0.0)\n        {\n          return NO_HIT;\n        }\n        // Find two points of intersection, t1 close and t2 far\n        float t1 = (-b - sqrt(discriminant)) / (2. * a);\n        float t2 = (-b + sqrt(discriminant)) / (2. * a);\n        float t = -1.0;\n        // First check if close intersection is valid\n        if (t1 > RAY_T_MIN && t1 < et)\n        {\n          t = t1;\n          \n          \n          vec3 phit = r.direction*t + r.point;\n          float noise = getNoise(s, phit);\n          if(noise > 0.){\n            return Hit(true, t, phit, normalize(phit - s.center), s.m, s.m.specular);\n          }\n        }\n        if (t2 > RAY_T_MIN && t2 < et)\n        {\n          t = t2;\n          \n          \n          vec3 phit = r.direction*t + r.point;\n          float noise = getNoise(s, phit);\n          if(noise > 0.){\n            return Hit(true, t, phit, normalize(phit - s.center), s.m, s.m.specular);\n          }\n        }\n        if(t == -1.0){\n          // Neither is valid\n          return NO_HIT;\n        }\n        return NO_HIT;\n        }\n        Ray eyeMakeRay(Eye e, vec2 point){\n        vec3 dir = e.forward + point.x * e.w * e.right + point.y * e.h * e.up;\n        return Ray(e.point, normalize(dir), RAY_T_MAX);\n        }\n        Eye createEye(vec3 point, vec3 target, vec3 upguide, float fov, float aspectRatio){\n        vec3 forward = normalize(target - point);\n        vec3 right = normalize(cross(forward, upguide));\n        vec3 up = cross(right, forward);\n        float h = tan(fov);\n        float w = h * aspectRatio;\n        return Eye(point, forward, right, up, h, w);\n        }\n        vec3 ptColor(Hit h, Eye e, Light l, vec3 color){\n        vec3 normal = h.normal;\n        vec3 surfacePos = h.point;\n        vec3 surfaceColor = color;\n        Material m = h.m;\n        vec3 surfaceToLight  = normalize(l.point - surfacePos);\n        vec3 surfaceToEye = normalize(e.point - surfacePos);\n        vec3 ambient = l.ambient * surfaceColor * l.intensity;\n        float dC = max(0.0, dot(normal, surfaceToLight));\n        vec3 diffuse = dC * surfaceColor * l.intensity;\n        float sC = 0.0;\n        if(dC > 0.0){\n          float cosA = max(0.0, dot(surfaceToEye, reflect(-surfaceToLight, normal)));\n          sC = pow(cosA, m.shininess);\n        }\n        vec3 specular = sC * m.specular * l.intensity;\n        float dist = length(l.point - surfacePos);\n        float attn = 1.0 / (1.0 + l.attn * dist*dist);\n        vec3 linear = ambient + attn*(specular + diffuse);\n        vec3 gamma = pow(linear, vec3(1./2.2, 1./2.2, 1./2.2));\n\n        return gamma;\n        }\n        Sphere createSphere(float r, vec2 nsc, float nst, vec3 color){\n        return Sphere(vec3(0), r, nsc, vec2(0), nst, Material(color, 1.0, false, 0.5, true, 1.52));\n        }\n        vec3 getIntersectionScene(Eye e, vec2 coord, Sphere[6] s, Light l[4]){\n        float x = coord.x;\n        float y = coord.y;\n        float scx = 2.0*x / u_resolution.x - 1.0;\n        float scy = -2.0*y / u_resolution.y + 1.0;\n        float t = RAY_T_MAX;\n\n        Ray ray = eyeMakeRay(e, vec2(scx, scy));\n        vec3 final = vec3(1.);\n\n        float ref = 1.0;\n        for(int i = 0; i < DEPTH; i++){\n          Hit closest;\n          for(int j = 0; j < SPHERES; j++){\n            Hit h = intersect(ray, s[j], t);\n            if(h.hit){\n              t = h.tMax;\n              closest = h;\n            }\n          }\n          if(RAY_T_MAX >= t){\n            vec3 mixture = vec3(1);\n            for(int j = 0; j < LIGHTS; j++){\n              mixture *= ptColor(closest, e, l[j], closest.color);\n            }\n            final *= mixture * ref;\n            if(closest.m.reflective){\n              ray = Ray(closest.point, reflect(ray.direction, closest.normal), RAY_T_MAX);\n              ref *= closest.m.reflectN;\n            } else if(closest.m.refractive) {\n              ray = Ray(closest.point, refraction(ray.direction, closest.normal, closest.m.refractN), RAY_T_MAX);\n            }\n            \n          }\n          t = RAY_T_MAX;\n        }\n        return final;\n        }\n        /**\n         * for crt\n         */\n        vec3 scanline(vec2 coord, vec3 screen)\n        {\n        screen.xyz -= sin((coord.y + (u_time * 29.0))) * 0.02;\n        return screen;\n        }\n\n        vec2 crt(vec2 coord, float bend)\n        {\n        // put in symmetrical coords\n        coord = (coord - 0.5) * 2.0;\n        coord *= 1.1;\n        // deform coords\n        coord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n        coord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n        // transform back to 0.0 - 1.0 space\n        coord  = (coord / 2.0) + 0.5;\n        return coord;\n        }\n\n        vec3 sampleSplit(Eye e, vec2 coord, Sphere[6] s, Light l[4])\n        {\n        vec3 frag;\n        vec2 ratio = coord/u_resolution;\n        //frag = getIntersectionScene(e, gl_FragCoord.xy, s, l);\n        frag.x = getIntersectionScene(e, vec2(ratio.x - 0.0025 * sin(u_time), ratio.y)*u_resolution, s, l).x;\n        frag.y = getIntersectionScene(e, coord, s, l).y;\n        frag.z = getIntersectionScene(e, vec2(ratio.x + 0.0025 * sin(u_time), ratio.y)*u_resolution, s, l).z;\n        return frag;\n        }\n\n        void main(){\n        vec2 ms = u_mouse.xy;\n        float width = u_oreso.x;\n        float height = u_oreso.y;\n\n        Material wood = Material(vec3(1, 1, 1), 0.5, true, 0.5, false, 1.0);\n        Material glass = Material(vec3(1, 1, 1), 1., false, 0.5, true, 1.52);\n\n        Sphere s[6];\n        float radius = SPHERE_RADIUS;\n        vec2 scale = SPHERE_BNS;\n        float nstep = SPHERE_STEP;\n\n        s[0] = createSphere(radius, scale, nstep, vec3(0.96, 0, 1));\n        radius *= SPHERE_RADIUS_GROWTH;\n        scale *= SPHERE_SCALE_GROWTH;\n        nstep *= SPHERE_STEP_GROWTH;\n\n        s[1] = createSphere(radius, scale, nstep, vec3(0.85, 0, 1));\n        radius *= SPHERE_RADIUS_GROWTH;\n        scale *= SPHERE_SCALE_GROWTH;\n        nstep *= SPHERE_STEP_GROWTH;\n        s[2] = createSphere(radius, scale, nstep, vec3(0.74, 0, 1));\n        radius *= SPHERE_RADIUS_GROWTH;\n        scale *= SPHERE_SCALE_GROWTH;\n        nstep *= SPHERE_STEP_GROWTH;\n        s[3] = createSphere(radius, scale, nstep, vec3(0.62, 0, 1));\n        radius *= SPHERE_RADIUS_GROWTH;\n        scale *= SPHERE_SCALE_GROWTH;\n        nstep *= SPHERE_STEP_GROWTH;\n        s[4] = createSphere(radius, scale, nstep, vec3(0.51, 0, 1));\n        radius *= SPHERE_RADIUS_GROWTH;\n        scale *= SPHERE_SCALE_GROWTH;\n        nstep *= SPHERE_STEP_GROWTH;\n        s[5] = createSphere(radius, scale, nstep, vec3(0.40, 0, 1));\n\n\n        Light l[4];\n\n        l[0] = Light(\n          vec3(12, 0, 0),\n          vec3(1),\n          0.1,\n          0.1\n        );\n\n        vec2 halfres = u_oreso.xy*0.5;\n\n        ms = halfres - ms;\n        ms /= halfres;\n\n        ms *= PI;\n\n        vec3 eye_pos = vec3(CAMERA_OFFSET + CAMERA_OFFSET*0.5*sin(ms.y*0.5), CAMERA_OFFSET, CAMERA_OFFSET*0.5*cos(ms.x*0.5));\n        vec3 target = vec3(ms.y, 0.0, ms.x); // \n        vec3 upguide = vec3(0.0, 0.0, 1.0);\n        float fov = CAMERA_FOV * PI/180.;\n        float aspectRatio = width / height;\n        Eye e = createEye(eye_pos, target, upguide, fov, aspectRatio);\n        vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n        uv.y = 1.0 - uv.y; // flip tex\n        vec2 crtCoords = crt(uv, 3.2);\n        // shadertoy has tiling textures. wouldn't be needed\n        // if you set up your tex params properly\n        if (crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0){\n          gl_FragColor = vec4(0.0);\n        } else {\n          // Split the color channels\n          vec3 v = sampleSplit(e, gl_FragCoord.xy, s, l);\n          // HACK: this bend produces a shitty moire pattern.\n          // Up the bend for the scanline\n          vec2 screenSpace = crtCoords * u_resolution.xy;\n          //vec3 currentJulia = getJulia(gl_FragCoord.xy);\n          gl_FragColor = vec4(scanline(screenSpace, v), 1.0);\n        }\n      }\n    `}\n    </GLBackground>\n  </>\n);\n","import React from 'react';\nimport GLBackground from '../components/GLBackground';\n\nexport default () => (\n  <>\n    <GLBackground>\n      {`\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n        #else\n        precision mediump float;\n        #endif\n        precision mediump int;\n        uniform vec2 u_resolution;\n        uniform vec2 u_mouse;\n        uniform float u_time;\n        \n        vec2 rot(vec2 p, float a) {\n          float c = cos(a), s = sin(a);\n          return vec2(\n            c * p.x - s * p.y,\n            s * p.x + c * p.y);\n            \n        }\n        \n        \n        float map(vec3 p) {\n          //p.x += sin(p.z * 0.25 + u_time) * 2.0;\n          //p.y += cos(p.z * 0.25 + u_time) * 2.0;\n          //p.xy = rot(p.xy, -p.z * 0.1);\n          vec3 m = mod(p, 2.0) - 1.0;\n          \n          return length(max(abs(m) - 0.1, 0.0)) - 0.001;\n        }\n\n        vec3 render(vec2 coord) {\n          vec2 uv = ( 2.0 * coord - u_resolution.xy ) / min(u_resolution.x, u_resolution.y);\n          vec3 dir = normalize(vec3(uv, 1.85));\n          vec3 pos = vec3(0, 0, u_time * 2.0);\n          dir.yz = rot(dir.yz, (u_mouse.y / u_resolution.y) * 1.0);\n          dir.zx = rot(dir.zx, (u_mouse.x / u_resolution.x) * 1.0);\n          float t = 0.0;\n          for(int i = 0 ; i < 90; i++) {\n            float k = map(dir * t + pos);\n            t += k * 0.85;\n          }\n          vec3 ip = dir;\n          return vec3(t * 0.005 * mix(vec3(0), vec3(1), t * 0.025));\n        }\n        \n        /**\n         * for crt\n         */\n        vec3 scanline(vec2 coord, vec3 screen) {\n          screen.xyz -= sin((coord.y + (u_time * 29.0))) * 0.02;\n          return screen;\n        }\n\n        vec2 crt(vec2 coord, float bend) {\n          // put in symmetrical coords\n          coord = (coord - 0.5) * 2.0;\n          coord *= 1.1;\n          // deform coords\n          coord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n          coord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n          // transform back to 0.0 - 1.0 space\n          coord  = (coord / 2.0) + 0.5;\n          return coord;\n        }\n        \n        vec3 sampleSplit(vec2 coord) {\n          vec3 frag;\n          vec2 ratio = coord/u_resolution;\n          frag.x = render(vec2(ratio.x - 0.0025 * sin(u_time), ratio.y)*u_resolution).x;\n          frag.y = render(coord).y;\n          frag.z = render(vec2(ratio.x + 0.0025 * sin(u_time), ratio.y)*u_resolution).z;\n          return frag;\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n          uv.y = 1.0 - uv.y; // flip tex\n          vec2 crtCoords = crt(uv, 3.2);\n          // shadertoy has tiling textures. wouldn't be needed\n          // if you set up your tex params properly\n          if (crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0){\n            gl_FragColor = vec4(0.0);\n          } else {\n            // Split the color channels\n            vec3 v = sampleSplit(gl_FragCoord.xy);\n            // HACK: this bend produces a shitty moire pattern.\n            // Up the bend for the scanline\n            vec2 screenSpace = crtCoords * u_resolution.xy;\n            gl_FragColor = vec4(scanline(screenSpace, v), 1.0);\n          }\n        }\n      `}\n    </GLBackground>\n  </>\n);\n","import React from 'react';\nimport GLBackground from '../components/GLBackground';\n\nexport default () => (\n  <>\n    <GLBackground>\n      {`\n        #ifdef GL_ES\n          precision mediump float;\n        #endif\n        \n        #extension GL_OES_standard_derivatives : enable\n        \n        uniform float u_time;\n        uniform vec2 u_mouse;\n        uniform vec2 u_resolution;\n        \n        const float PI = acos(-1.0);\n        \n        float distanceFunction(vec3 p){\n          vec3 pp = abs(fract(p + vec3(0.0, 0.0, u_time)) * 2.0 - 1.0);\n          \n          return min(p.y + 1.0, max(pp.z, pp.x) + p.y * 0.5);\n        }\n        \n        vec3 calculateNormal(vec3 p){\n          const float delta = 0.001;\n          \n          float startd = distanceFunction(p);\n          float dx = startd - distanceFunction(vec3(p.x - delta, p.y, p.z));\n          float dy = startd - distanceFunction(vec3(p.x, p.y - delta, p.z));\n          float dz = startd - distanceFunction(vec3(p.x, p.y, p.z - delta));\n          \n          return normalize(vec3(dx, dy, dz));\n        }\n        \n        vec3 render(vec2 coord) {\n        \n          vec2 position = coord.xy / u_resolution.xy;\n          vec3 vector = normalize(vec3((1.0 - (u_mouse.xy / u_resolution.xy) * 0.5) + position * 2.0 - 1.0, 1.0));\n          \n          const int steps = 128;\n          const float rSteps = 1.0 / float(steps);\n          \n          vec3 worldPosition = vec3(0.0);\n          bool hit = false;\n          float woah = 0.0;\n          \n          for (int i = 0; i < steps; ++i){\n            float d = distanceFunction(worldPosition);\n            woah = float(i);\n            \n            hit = true;\n            if (abs(d) < 0.001 || length(worldPosition) > 64.0) break;\n            hit = false;\n            \n            worldPosition += vector * d * 0.5;\n          }\n          \n          vec3 normal = calculateNormal(worldPosition);\n          //vec3 halfVector = normalize(normal + vector);\n          //float NoV = dot(normal, -vector);\n        \n          return vec3(woah * 0.02) / length(worldPosition) * 3.0;\n        }\n        \n        /**\n         * for crt\n         */\n        vec3 scanline(vec2 coord, vec3 screen)\n        {\n          screen.xyz -= sin((coord.y + (u_time * 29.0))) * 0.02;\n          return screen;\n        }\n        \n        vec2 crt(vec2 coord, float bend)\n        {\n          // put in symmetrical coords\n          coord = (coord - 0.5) * 2.0;\n          coord *= 1.1;\n          // deform coords\n          coord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n          coord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n          // transform back to 0.0 - 1.0 space\n          coord  = (coord / 2.0) + 0.5;\n          return coord;\n        }\n        \n        vec3 sampleSplit(vec2 coord)\n        {\n          vec3 frag;\n          vec2 ratio = coord/u_resolution;\n          frag.x = render(vec2(ratio.x - 0.0025 * sin(u_time), ratio.y) * u_resolution).x;\n          frag.y = render(coord).y;\n          frag.z = render(vec2(ratio.x + 0.0025 * sin(u_time), ratio.y) * u_resolution).z;\n          return frag;\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n          uv.y = 1.0 - uv.y; // flip tex\n          vec2 crtCoords = crt(uv, 3.2);\n          if (crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0){\n            gl_FragColor = vec4(0.0);\n          } else {\n            vec3 v = sampleSplit(gl_FragCoord.xy);\n            vec2 screenSpace = crtCoords * u_resolution.xy;\n            gl_FragColor = vec4(scanline(screenSpace, v), 1.0);\n          }\n        }\n      `}\n    </GLBackground>\n  </>\n);\n","import React from 'react';\nimport GLBackground from '../components/GLBackground';\n\nexport default () => (\n  <>\n    <GLBackground>\n      {`\n        #define ITERATIONS 50.\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\n          precision highp float;\n        #else\n          precision mediump float;\n        #endif\n        precision mediump int;\n       \n        \n        uniform float u_time;\n        uniform vec2 u_mouse;\n        uniform vec2 u_resolution;\n        uniform vec2 u_oreso;\n        \n        const float TIME_SCALE = 0.1;\n        \n        float modI(float a,float b) {\n          float m=a - floor((a + 0.5) / b) * b;\n          return floor(m + 0.5);\n        }\n        \n        vec3 getJulia(vec2 pixel){\n        \n          vec2 mid = u_oreso * 0.5;\n          vec2 m = mid - u_mouse;\n          \n          float w = u_resolution.x;\n          float h = u_resolution.y;\n          \n          float time = u_time * TIME_SCALE;\n          \n          m /= mid;\n          \n          float re = m.x * cos(time);\n          float im = m.y * -sin(time);\n          \n          float newRe = 1.5 * (pixel.x - w / 2.0) / (0.5 * w);\n          float newIm = (pixel.y - h / 2.0) / (0.5 * h);\n          float oldRe, oldIm;\n          \n          float steps;\n          \n          for (float i = 0.; i < ITERATIONS; i++){\n            steps = i;\n            oldRe = newRe;\n            oldIm = newIm;\n            \n            newRe = oldRe * oldRe - oldIm * oldIm + re;\n            newIm = 2.0 * oldRe * oldIm + im;\n            \n            if ((newRe * newRe + newIm * newIm) > 4.) break;\n          }\n          \n          float s_f = steps;\n          float r = 1. - abs(1. - 2. * s_f/ITERATIONS);\n          float g = 1. - abs(1. - 2. * s_f/ITERATIONS);\n          float b = 1. - abs(1. - 2. * s_f/ITERATIONS);\n          \n          return vec3(r, g, b);\n        }\n        \n        /**\n         * for crt\n         */\n        vec3 scanline(vec2 coord, vec3 screen) {\n          screen.xyz -= sin((coord.y + (u_time * 29.0))) * 0.02;\n          return screen;\n        }\n        \n        vec2 crt(vec2 coord, float bend) {\n          // put in symmetrical coords\n          coord = (coord - 0.5) * 2.0;\n          coord *= 1.1;\n          // deform coords\n          coord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n          coord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n          // transform back to 0.0 - 1.0 space\n          coord  = (coord / 2.0) + 0.5;\n          return coord;\n        }\n        \n        vec3 sampleSplit(vec2 coord) {\n          vec3 frag;\n          vec2 ratio = coord/u_resolution;\n          frag.x = getJulia(vec2(ratio.x - 0.0025 * sin(u_time), ratio.y)*u_resolution).x;\n          frag.y = getJulia(coord).y;\n          frag.z = getJulia(vec2(ratio.x + 0.0025 * sin(u_time), ratio.y)*u_resolution).z;\n          return frag;\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n          uv.y = 1.0 - uv.y; // flip tex\n          vec2 crtCoords = crt(uv, 3.2);\n          // shadertoy has tiling textures. wouldn't be needed\n          // if you set up your tex params properly\n          if (crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0){\n            gl_FragColor = vec4(0.0);\n          } else {\n            // Split the color channels\n            vec3 v = sampleSplit(gl_FragCoord.xy);\n            // HACK: this bend produces a shitty moire pattern.\n            // Up the bend for the scanline\n            vec2 screenSpace = crtCoords * u_resolution.xy;\n            vec3 currentJulia = getJulia(gl_FragCoord.xy);\n            gl_FragColor = vec4(scanline(screenSpace, v), 1.0);\n          }\n        }\n      `}\n    </GLBackground>\n  </>\n);\n","import React from 'react';\nimport GLBackground from '../components/GLBackground';\n\nexport default () => (\n  <>\n    <GLBackground>\n      {`\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        #extension GL_OES_standard_derivatives : enable\n        \n        uniform sampler2D tex;\n        \n        uniform vec2 u_mouse;\n        uniform vec2 u_resolution;\n        uniform float u_time; \n        \n        vec3 rotatey(in vec3 p, float ang) {\n          return vec3(p.x * cos(ang) - p.z * sin(ang), p.y, p.x * sin(ang) + p.z * cos(ang));\n        }\n        vec3 rotatex(in vec3 p, float ang) {\n          return vec3(p.x, p.y * cos(ang) - p.z * sin(ang), p.y * sin(ang) + p.z * cos(ang));\n        }\n        vec3 rotatez(in vec3 p, float ang) {\n          return vec3(p.x * cos(ang) - p.y * sin(ang), p.x * sin(ang) + p.y * cos(ang), p.z);\n        }\n        \n        float scene(vec3 p) {\n          vec2 offset = u_mouse / u_resolution;\n          p = rotatey(p, offset.x); \n          p = rotatex(p, offset.y); \n          p = rotatez(p, 1.0); \n          float d1 = length(p) - 0.5 + sin(-4.0 * u_time + 60.0 * p.x) * 0.01 + sin(1.5 * u_time + 50.0 * p.x * p.z) * 0.02; \n          return d1;\n        }\n        \n        vec3 get_normal(vec3 p) {\n          vec3 eps = vec3(0.001,0,0); \n          float nx = scene(p + eps.xyy) - scene(p - eps.xyy); \n          float ny = scene(p + eps.yxy) - scene(p - eps.yxy); \n          float nz = scene(p + eps.yyx) - scene(p - eps.yyx); \n          return normalize(vec3(nx,ny,nz)); \n        }\n\n        vec3 render(vec2 coord) {\n          vec2 p = 2.0 * (coord.xy / u_resolution) - 1.0; \n          p.x *= u_resolution.x / u_resolution.y; \n          vec3 color = vec3(0); \n        \n        \n          color = vec3(1.0 - length(p * 0.1)) * 0.4; \n          \n          vec3 ro = vec3(0,0,1.0); \n          vec3 rd = normalize(vec3(p.x,p.y,-1.0));  \n          vec3 pos = ro; \n          float dist = 0.0; \n          for (int i = 0; i < 64; i++) {\n            float d = scene(pos);\n            pos += rd * d;\n            dist += d;\n          }\n          if (dist < 100.0) {\n            vec3 lightpos = vec3(100.0, 0.0, 0.0); \n            vec3 n = get_normal(pos);\n            //vec3 l = normalize(vec3(1, 0, 0.0)); \n            vec3 l = normalize(lightpos-pos); \n            float diff = 0.0 * clamp(dot(n, l), 0.0, 1.0); \n            float fres = clamp(dot(n, -rd), 0.0, 1.0); \n            float amb = 0.1; \n            float spec0 = 0.5 * pow(clamp(dot(reflect(n, l), normalize(vec3(-1.0, 0, 1.0))), 0.0, 1.0), 50.0); \n            float spec1 = 0.5 * pow(clamp(dot(reflect(n, l), normalize(vec3(1.0, 0, 1.0))), 0.0, 1.0), 50.0); \n            float spec2 = 3.0 * pow(clamp(dot(reflect(n, l), normalize(vec3(0.0, 0.5, 1.0))), 0.0, 1.0), 10.0); \n            color = diff * vec3(1.0) / dist;\n            color += 0.0 * amb * vec3(1.0, 1.0, 1.0) * clamp(p.y, 0.0, 1.0) * 1.0;\n            color = mix(vec3(1, 1, 1) * 0.2,vec3(1, 1, 1) * 0.0, fres);\n            color += spec0 * vec3(1, 1, 1);\n            color += smoothstep(0.0, 1.0, spec1)*vec3(1, 1, 1);\n            color += 1.0 * pow(spec1, 2.0)*vec3(1, 1, 1);\n            color += smoothstep(0.0, 0.5, spec2)*vec3(1, 1, 1)*pos.y*2.0; \n          }\n        \n          return color; \n        }        \n        \n        /**\n         * for crt\n         */\n        vec3 scanline(vec2 coord, vec3 screen) {\n          screen.xyz -= sin((coord.y + (u_time * 29.0))) * 0.02;\n          return screen;\n        }\n        \n        vec2 crt(vec2 coord, float bend) {\n          // put in symmetrical coords\n          coord = (coord - 0.5) * 2.0;\n          coord *= 1.1;\n          // deform coords\n          coord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n          coord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n          // transform back to 0.0 - 1.0 space\n          coord  = (coord / 2.0) + 0.5;\n          return coord;\n        }\n        \n        vec3 sampleSplit(vec2 coord) {\n          vec3 frag;\n          vec2 ratio = coord/u_resolution;\n          frag.x = render(vec2(ratio.x - 0.0025 * sin(u_time), ratio.y)*u_resolution).x;\n          frag.y = render(coord).y;\n          frag.z = render(vec2(ratio.x + 0.0025 * sin(u_time), ratio.y)*u_resolution).z;\n          return frag;\n        }\n\n        void main() {\n          vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n          uv.y = 1.0 - uv.y; // flip tex\n          vec2 crtCoords = crt(uv, 3.2);\n          // shadertoy has tiling textures. wouldn't be needed\n          // if you set up your tex params properly\n          if (crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0){\n            gl_FragColor = vec4(0.0);\n          } else {\n            // Split the color channels\n            vec3 v = sampleSplit(gl_FragCoord.xy);\n            // HACK: this bend produces a shitty moire pattern.\n            // Up the bend for the scanline\n            vec2 screenSpace = crtCoords * u_resolution.xy;\n            gl_FragColor = vec4(scanline(screenSpace, v), 1.0);\n          }\n        }\n      `}\n    </GLBackground>\n  </>\n);\n","const lerp = (a, b, t) => a + (b - a) * (t * t * (3 - 2 * t));\nconst charLerp = (a, b, t) => String.fromCharCode(lerp(a.charCodeAt(0), b.charCodeAt(0), t));\n\nexport default (str1, str2, t, mode) => {\n  let a = str1;\n  let b = str2;\n\n  if (t >= 1) {\n    return str2;\n  }\n  if (t <= 0) {\n    return str1;\n  }\n  // two modes\n  // 1. char-by-char interpolation\n  // 2. full string interpolation\n\n  // get string lengths\n  const len1 = a.length;\n  const len2 = b.length;\n\n  // pick the longer string length\n  const longer = Math.max(len1, len2);\n\n  // add whitespace padding\n  if (len1 < len2) {\n    for (let i = len2 - len1; i > 0; i -= 1) {\n      a += ' ';\n    }\n  } else if (len2 < len1) {\n    for (let i = len1 - len2; i > 0; i -= 1) {\n      b += ' ';\n    }\n  }\n  let result = '';\n  if (mode === 1) {\n    // get the actual value of each index\n    const indexValue = 1 / longer;\n\n    // get the character position (nearest)\n    const pos = Math.max(1, Math.floor(longer * t) + 1);\n\n    // pick all characters that aren't needed for interpolation\n    for (let i = 0; i < pos - 1; i += 1) {\n      result += b.charAt(i);\n    }\n\n    // interpolate character\n    const char1 = a.charAt(pos - 1);\n    const char2 = b.charAt(pos - 1);\n    const grad = (t - pos * indexValue) / indexValue;\n    const interpolated = charLerp(char1, char2, grad);\n\n    result += interpolated;\n    // get the strings after the pos\n    for (let i = pos; i < longer; i += 1) {\n      result += a.charAt(i);\n    }\n  }\n  if (mode === 2) {\n    for (let i = 0; i < longer; i += 1) {\n      const char1 = a.charAt(i);\n      const char2 = b.charAt(i);\n      result += charLerp(char1, char2, t);\n    }\n  }\n  return result;\n};\n","/* eslint-disable react/prop-types */\nimport React, { useRef, useEffect } from 'react';\n\nimport { Link } from 'react-router-dom';\nimport { addTarget, removeTarget } from './Cursor';\nimport stringLerp from '../utils/stringLerp';\n\nconst INCREMENTS = 1.0 / 64.0;\nconst DETECTION_RADIUS = 32;\n\nconst DURATION = 0.4;\nconst MODE = 2;\n\nexport default ({ target, start, end }) => {\n  const navRef = useRef(null);\n\n  useEffect(() => {\n    const item = navRef.current;\n\n    addTarget(item);\n\n    let timer = 0.0;\n    let reversed = false;\n    let raf;\n\n    const update = () => {\n      if (reversed) {\n        if (timer > 0.0) {\n          timer -= INCREMENTS;\n          raf = requestAnimationFrame(update);\n        }\n      } else if (timer < DURATION) {\n        timer += INCREMENTS;\n        raf = requestAnimationFrame(update);\n      }\n      item.innerHTML = stringLerp(start, end, timer / DURATION, MODE);\n    };\n\n    const onMouseMove = (e) => {\n      const y = e.clientY;\n      const x = e.clientX;\n\n\n      const width = item.clientWidth;\n      const height = item.clientHeight;\n\n      const rect = item.getBoundingClientRect();\n\n      const { top } = rect;\n      const { left } = rect;\n\n      const hw = width * 0.5;\n      const hh = height * 0.5;\n\n\n      const ex = left + hw;\n      const ey = top + hh;\n\n      const dx = x - ex; const\n        dy = y - ey;\n\n      if (dx * dx + dy * dy <= DETECTION_RADIUS * DETECTION_RADIUS) {\n        if (reversed) {\n          reversed = false;\n          update();\n        }\n      } else if (!reversed) {\n        reversed = true;\n        update();\n      }\n    };\n\n    window.addEventListener('mousemove', onMouseMove);\n\n    return () => {\n      removeTarget(item);\n      cancelAnimationFrame(raf);\n      window.removeEventListener('mousemove', onMouseMove);\n    };\n  });\n\n  return (\n    <Link\n      innerRef={navRef}\n      className=\"nav-item\"\n      id={`nav-${target}`}\n      to={`/${target}`}\n    >\n      {start}\n    </Link>\n  );\n};\n","/* eslint-disable react/prop-types */\nimport React, { useRef, useEffect } from 'react';\n\nimport { Link } from 'react-router-dom';\n\nimport NavItem from './NavItem';\nimport { addTarget, removeTarget } from './Cursor';\n\nimport '../css/Nav.css';\n\nconst Logo = ({ title }) => {\n  const ref = useRef(null);\n  useEffect(() => {\n    const item = ref.current;\n\n    addTarget(item);\n\n    return () => {\n      removeTarget(item);\n    };\n  });\n  return (\n    <Link innerRef={ref} className=\"Logo\" to=\"/\">\n      {title.split('').map((x, i) => (<span className={`char${i}`}>{x}</span>))}\n    </Link>\n  );\n};\n\nexport default () => (\n  <nav>\n    <Logo title=\"LXSMNSYC\" />\n    <NavItem target=\"contacts\" start=\"contacts\" end=\"CONTACTS\" />\n    <NavItem target=\"about\" start=\"about\" end=\"ABOUT\" />\n    <NavItem target=\"works\" start=\"works\" end=\"WORKS\" />\n    <NavItem target=\"menu\" start=\"menu\" end=\"MENU\" />\n  </nav>\n);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","/* eslint-disable react/jsx-filename-extension */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from 'react';\n\nimport { HashRouter, Route } from 'react-router-dom';\n\nimport Index from './pages/Index';\nimport Menu from './pages/Menu';\nimport About from './pages/About';\nimport Works from './pages/Works';\nimport Contacts from './pages/Contacts';\n\nimport Nav from './components/Nav';\nimport Cursor from './components/Cursor';\n\nexport default () => (\n  <HashRouter hashType=\"slash\">\n    <Nav />\n    <Route exact path=\"/\" component={Index} />\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/works\" component={Works} />\n    <Route path=\"/menu\" component={Menu} />\n    <Route path=\"/contacts\" component={Contacts} />\n    <Cursor />\n  </HashRouter>\n);\n"],"sourceRoot":""}