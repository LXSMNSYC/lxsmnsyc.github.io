<!doctype HTML>
<html>

<head>
    <!-- Set character encoding for the document -->
    <meta charset="utf-8">

    <!-- Viewport for responsive web design -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

    <!-- Document Title -->
    <title>LXSMNSYC</title>

    <!-- Meta Description -->
    <meta name="description" content="Description of the page less than 150 characters">

    <link rel="stylesheet" href="../css/main.css">
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-119261077-2"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-119261077-2');
	</script>
	<!-- Google Analytics -->
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-119261077-2', 'auto');
	ga('send', 'pageview');
	</script>
	<!-- End Google Analytics -->
</head>

<body>
    <canvas id="gl" width="640" height="480"></canvas>
	
	
	<nav>
		<a class="logo" id="nav-logo" href="../">LXSMNSYC</a>
		<a class="nav-item" id="nav-menu" href="#">menu</a>
		<a class="nav-item" id="nav-about" href="about">about</a>
		<a class="nav-item" id="nav-contacts" href="#">contacts</a>
		<a class="nav-item" id="nav-works" href="works">works</a>
	</nav>
	

	<div id="cursor"></div>
	
	
	<script id="gl-frag" type="x-shader/x-fragment">
		#ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
	#else
		precision mediump float;
	#endif
	precision mediump int;

	uniform vec2 u_resolution;
	uniform vec2 u_oreso;
	uniform vec2 u_mouse;
	uniform float u_time;

	#define PI 3.14159265358979323
	
	#define SPHERE_RADIUS 1.0
	
	
	const int MAX_MARCHING_STEPS = 256;
	const float MIN_DIST = 0.0;
	const float MAX_DIST = 96.0;
	const float EPSILON = 0.0001;
	
	const float BRIGHTNESS = 0.75;
	
	/*
	 * SDF
	 */
	
	float sdSphere( vec3 p, float s )
	{
		return length(p)-s;
	}
	float sdBox( vec3 p, vec3 b )
	{
		vec3 d = abs(p) - b;
		return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
	}
	float sdTorus( vec3 p, vec2 t )
	{
		vec2 q = vec2(length(p.xz)-t.x,p.y);
		return length(q)-t.y;
	}
	
	/**
	 *
	 *
	float repeat( in vec3 p, in vec3 c )
	{
		vec3 q = mod(p,c)-0.5*c;
		return sdSphere( q,  SPHERE_RADIUS);
	} */
	vec3 repeat(vec3 p, vec3 c)
	{
		return mod(p,c)-0.5*c;
	}
	
	float opU( float d1, float d2 )
	{
		return min(d1,d2);
	}
	float opS( float d1, float d2 )
	{
		return max(-d1,d2);
	}
	// power smooth min (k = 8);
	float smin( float a, float b, float k )
	{
		float res = exp2( -k*a ) + exp2( -k*b );
		return -log2( res )/k;
	}
	/**
	 * Signed distance function describing the scene.
	 * 
	 * Absolute value of the return value indicates the distance to the surface.
	 * Sign indicates whether the point is inside or outside the surface,
	 * negative indicating inside.
	 */
	float sceneSDF(vec3 samplePoint) {  
		float k = 2.;
		vec3 rep = repeat(samplePoint, vec3(32));
		float boxlen = 4. + sin(u_time)*4.;
		float box1 = sdBox(rep, vec3(0.1, 0.1, boxlen));
		float box2 = sdBox(rep, vec3(0.1, boxlen, 0.1));
		float box3 = sdBox(rep, vec3(boxlen, 0.1, 0.1));
		
		float box12 = smin(box1, box2, k);
		float box123 = smin(box12, box3, k);
		
		float sphereoffs = 4. + cos(u_time)*4.;
		float sphere1 = sdSphere(repeat(samplePoint + vec3(0., sphereoffs, 0.), vec3(32)), 1.0);
		float sphere2 = sdSphere(repeat(samplePoint + vec3(sphereoffs, 0., 0.), vec3(32)), 1.0);
		float sphere3 = sdSphere(repeat(samplePoint + vec3(0., 0., sphereoffs), vec3(32)), 1.0);
		float sphere4 = sdSphere(repeat(samplePoint + vec3(0., -sphereoffs, 0.), vec3(32)), 1.0);
		float sphere5 = sdSphere(repeat(samplePoint + vec3(-sphereoffs, 0., 0.), vec3(32)), 1.0);
		float sphere6 = sdSphere(repeat(samplePoint + vec3(0., 0., -sphereoffs), vec3(32)), 1.0);
		
		float sphere12 = smin(sphere1, sphere2, k);
		float sphere34 = smin(sphere3, sphere4, k);
		float sphere56 = smin(sphere5, sphere6, k);
		float sphere1234 = smin(sphere12, sphere34, k);
		float sphere = smin(sphere1234, sphere56, k);
		
		return smin(box123, sphere, k);
	}
	
	/**
	 * Return the shortest distance from the eyepoint to the scene surface along
	 * the marching direction. If no part of the surface is found between start and end,
	 * return end.
	 * 
	 * eye: the eye point, acting as the origin of the ray
	 * marchingDirection: the normalized direction to march in
	 * start: the starting distance away from the eye
	 * end: the max distance away from the ey to march before giving up
	 */
	float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
		float depth = start;
		for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
			float dist = sceneSDF(eye + depth * marchingDirection);
			if (dist < EPSILON) {
				return depth;
			}
			depth += dist;
			if (depth >= end) {
				return end;
			}
		}
		return end;
	}
				

	/**
	 * Return the normalized direction to march in from the eye point for a single pixel.
	 * 
	 * fieldOfView: vertical field of view in degrees
	 * size: resolution of the output image
	 * fragCoord: the x,y coordinate of the pixel in the output image
	 */
	vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
		vec2 xy = fragCoord - size / 2.0;
		float z = size.y / tan(radians(fieldOfView) / 2.0);
		return normalize(vec3(xy, -z));
	}

	/**
	 * Using the gradient of the SDF, estimate the normal on the surface at point p.
	 */
	vec3 estimateNormal(vec3 p) {
		return normalize(vec3(
			sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
			sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
			sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
		));
	}
	
	/**
	 * Lighting contribution of a single point light source via Phong illumination.
	 * 
	 * The vec3 returned is the RGB color of the light's contribution.
	 *
	 * k_a: Ambient color
	 * k_d: Diffuse color
	 * k_s: Specular color
	 * alpha: Shininess coefficient
	 * p: position of point being lit
	 * eye: the position of the camera
	 * lightPos: the position of the light
	 * lightIntensity: color/intensity of the light
	 *
	 * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description
	 */
	vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
							  vec3 lightPos, vec3 lightIntensity) {
		vec3 N = estimateNormal(p);
		vec3 L = normalize(lightPos - p);
		vec3 V = normalize(eye - p);
		vec3 R = normalize(reflect(-L, N));
		
		float dotLN = dot(L, N);
		float dotRV = dot(R, V);
		
		if (dotLN < 0.0) {
			// Light not visible from this point on the surface
			return vec3(0.0, 0.0, 0.0);
		} 
		
		if (dotRV < 0.0) {
			// Light reflection in opposite direction as viewer, apply only diffuse
			// component
			return lightIntensity * (k_d * dotLN);
		}
		return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
	}

	/**
	 * Lighting via Phong illumination.
	 * 
	 * The vec3 returned is the RGB color of that point after lighting is applied.
	 * k_a: Ambient color
	 * k_d: Diffuse color
	 * k_s: Specular color
	 * alpha: Shininess coefficient
	 * p: position of point being lit
	 * eye: the position of the camera
	 *
	 * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description
	 */
	vec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {
		const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);
		vec3 color = ambientLight * k_a;
		
		vec3 light1Pos = vec3(4.0 * sin(u_time),
							  2.0,
							  4.0 * cos(u_time));
		vec3 light1Intensity = vec3(0.4, 0.4, 0.4);
		
		color += phongContribForLight(k_d, k_s, alpha, p, eye,
									  light1Pos,
									  light1Intensity);
		
		vec3 light2Pos = vec3(2.0 * sin(0.37 * u_time),
							  2.0 * cos(0.37 * u_time),
							  2.0);
		vec3 light2Intensity = vec3(0.4, 0.4, 0.4);
		
		color += phongContribForLight(k_d, k_s, alpha, p, eye,
									  light2Pos,
									  light2Intensity);    
		return color;
	}

	/**
	 * Return a transform matrix that will transform a ray from view space
	 * to world coordinates, given the eye point, the camera target, and an up vector.
	 *
	 * This assumes that the center of the camera is aligned with the negative z axis in
	 * view space when calculating the ray marching direction. See rayDirection.
	 */
	mat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {
		// Based on gluLookAt man page
		vec3 f = normalize(center - eye);
		vec3 s = normalize(cross(f, up));
		vec3 u = cross(s, f);
		return mat3(s, u, -f);
	}
	
	vec3 greyscale(vec3 color){
		float clinear = 0.2126*color.x + 0.7152*color.y + 0.0722*color.z;
		if(clinear <= 0.0031308){
			return vec3(clinear*12.92);
		}
		return vec3(1.055*pow(clinear, 1./2.4) - 0.055);
	}
	
	vec3 render(vec2 coord){
		vec3 viewDir = rayDirection(45.0, u_resolution.xy, coord.xy);
		vec3 eye = vec3(0.0, 2.5, u_time);
		vec2 halfr = u_oreso*0.5;
		vec2 mouse = (halfr - u_mouse)/halfr;
		float pi = 2.*3.14159265358979;
		float mx = mouse.x;
		float my = mouse.y;
		mat3 viewToWorld = viewMatrix(eye, eye + vec3(5.0*mx, 5.0*my, 5.0), vec3(0.0, 1.0, 0.0));
		
		vec3 worldDir = viewToWorld * viewDir;
		
		float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);
		
		if (dist > MAX_DIST - EPSILON) {
			// Didn't hit anything
			return vec3(0.0);
		}
		else {
			// The closest point on the surface to the eyepoint along the view ray
			vec3 p = eye + dist * worldDir;
			
			// Use the surface normal as the ambient color of the material
			vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;;
			vec3 K_d = K_a;
			vec3 K_s = vec3(1.0, 1.0, 1.0);
			float shininess = 10.0;
			
			vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);
			
			return greyscale(color);
		}
	
	}
	
	/**
	 *	for crt
	 */
	vec3 scanline(vec2 coord, vec3 screen)
	{
		screen.xyz -= sin((coord.y + (u_time * 29.0))) * 0.02;
		return screen;
	}
	
	vec2 crt(vec2 coord, float bend)
	{
		// put in symmetrical coords
		coord = (coord - 0.5) * 2.0;

		coord *= 1.1;	

		// deform coords
		coord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);
		coord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);

		// transform back to 0.0 - 1.0 space
		coord  = (coord / 2.0) + 0.5;

		return coord;
	}
	
	vec3 sampleSplit(vec2 coord)
	{
		vec3 frag;
		vec2 ratio = coord/u_resolution;
		frag.x = render(vec2(ratio.x - 0.0025 * sin(u_time), ratio.y)*u_resolution).x;
		frag.y = render(coord).y;
		frag.z = render(vec2(ratio.x + 0.0025 * sin(u_time), ratio.y)*u_resolution).z;
		return frag;
	}
	
	void main(){
		vec2 uv = gl_FragCoord.xy / u_resolution.xy;
		uv.y = 1.0 - uv.y; // flip tex
		vec2 crtCoords = crt(uv, 3.2);

		// shadertoy has tiling textures. wouldn't be needed
		// if you set up your tex params properly
		if (crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0){
			gl_FragColor = vec4(0.0);
		} else {
			// Split the color channels
			vec3 v = sampleSplit(gl_FragCoord.xy);

			// HACK: this bend produces a shitty moire pattern.
			// Up the bend for the scanline
			vec2 screenSpace = crtCoords * u_resolution.xy;
			//vec3 currentJulia = getJulia(gl_FragCoord.xy);
			gl_FragColor = vec4(scanline(screenSpace, v)*BRIGHTNESS, 1.0);
		}
	}
	</script>
	<script text="type/javascript" src="../js/cursor.js"></script>

	<script text="type/javascript" src="../js/gl.js"></script>

	<script text="type/javascript" src="../js/charming.js"></script>

	<script text="type/javascript" src="../js/string_lerp.js"></script>
	<script text="type/javascript" src="../js/hover_interpolator.js"></script>
	<script text="type/javascript">
		charming(document.getElementById("nav-logo"));
	</script>
</body>

</html>